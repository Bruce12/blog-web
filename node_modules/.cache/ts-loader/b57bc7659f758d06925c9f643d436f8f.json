{"remainingRequest":"/Users/lanjianhua/Desktop/lanjianhua/blog-web/node_modules/babel-loader/lib/index.js!/Users/lanjianhua/Desktop/lanjianhua/blog-web/node_modules/ts-loader/index.js??ref--14-2!/Users/lanjianhua/Desktop/lanjianhua/blog-web/node_modules/cache-loader/dist/cjs.js??ref--0-0!/Users/lanjianhua/Desktop/lanjianhua/blog-web/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/lanjianhua/Desktop/lanjianhua/blog-web/src/components/DragTree/index.vue?vue&type=script&lang=ts&","dependencies":[{"path":"/Users/lanjianhua/Desktop/lanjianhua/blog-web/src/components/DragTree/index.vue","mtime":1588936943000},{"path":"/Users/lanjianhua/Desktop/lanjianhua/blog-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/lanjianhua/Desktop/lanjianhua/blog-web/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/lanjianhua/Desktop/lanjianhua/blog-web/node_modules/ts-loader/index.js","mtime":499162500000},{"path":"/Users/lanjianhua/Desktop/lanjianhua/blog-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/lanjianhua/Desktop/lanjianhua/blog-web/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["import \"core-js/modules/es6.object.define-property\";\nimport \"core-js/modules/es6.object.define-properties\";\nimport \"core-js/modules/es7.object.get-own-property-descriptors\";\nimport \"core-js/modules/es6.array.for-each\";\nimport \"core-js/modules/es6.array.filter\";\nimport \"core-js/modules/es6.object.keys\";\nimport _defineProperty from \"/Users/lanjianhua/Desktop/lanjianhua/blog-web/node_modules/@babel/runtime-corejs2/helpers/esm/defineProperty\";\nimport _objectWithoutProperties from \"/Users/lanjianhua/Desktop/lanjianhua/blog-web/node_modules/@babel/runtime-corejs2/helpers/esm/objectWithoutProperties\";\nimport \"core-js/modules/es6.array.map\";\nimport _toConsumableArray from \"/Users/lanjianhua/Desktop/lanjianhua/blog-web/node_modules/@babel/runtime-corejs2/helpers/esm/toConsumableArray\";\nimport \"core-js/modules/es7.symbol.async-iterator\";\nimport \"core-js/modules/es6.symbol\";\nimport \"core-js/modules/web.dom.iterable\";\nimport _classCallCheck from \"/Users/lanjianhua/Desktop/lanjianhua/blog-web/node_modules/@babel/runtime-corejs2/helpers/esm/classCallCheck\";\nimport _createClass from \"/Users/lanjianhua/Desktop/lanjianhua/blog-web/node_modules/@babel/runtime-corejs2/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/Users/lanjianhua/Desktop/lanjianhua/blog-web/node_modules/@babel/runtime-corejs2/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/Users/lanjianhua/Desktop/lanjianhua/blog-web/node_modules/@babel/runtime-corejs2/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/Users/lanjianhua/Desktop/lanjianhua/blog-web/node_modules/@babel/runtime-corejs2/helpers/esm/inherits\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport * as tslib_1 from \"tslib\";\nimport { Component, Vue, Watch, Prop } from 'vue-property-decorator';\n\nvar default_1 =\n/*#__PURE__*/\nfunction (_Vue) {\n  _inherits(default_1, _Vue);\n\n  function default_1() {\n    var _this;\n\n    _classCallCheck(this, default_1);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(default_1).apply(this, arguments));\n    _this.rootCursorPosition = {\n      node: {\n        nodes: [],\n        level: 0,\n        pathStr: '',\n        ind: 1,\n        path: []\n      },\n      placement: 'before'\n    };\n    _this.currentValue = _this.value;\n    _this.preventDrag = false;\n    _this.isDragging = false;\n    _this.mouseIsDown = false;\n    _this.lastSelectedNode = {};\n    _this.scrollAreaHeight = 70;\n    _this.scrollSpeed = 0;\n    _this.scrollIntervalId = 0;\n    _this.maxScrollSpeed = 20;\n    _this.lastMousePos = {\n      x: 0,\n      y: 0\n    };\n    return _this;\n  }\n\n  _createClass(default_1, [{\n    key: \"onValueChange\",\n    value: function onValueChange(value) {\n      this.currentValue = value;\n    }\n  }, {\n    key: \"mounted\",\n    value: function mounted() {\n      if (this.isRoot) {\n        document.addEventListener('mouseup', this.onDocumentMouseupHandler);\n      }\n    }\n  }, {\n    key: \"beforeDestroy\",\n    value: function beforeDestroy() {\n      document.removeEventListener('mouseup', this.onDocumentMouseupHandler);\n    }\n    /**\n     * tree 外层 鼠标移动\n     */\n\n  }, {\n    key: \"onMousemoveHandler\",\n    value: function onMousemoveHandler(event) {\n      if (!this.isRoot) {\n        this.getRoot().onMousemoveHandler(event);\n        return;\n      }\n\n      if (this.preventDrag) return;\n      var initiaDraggingState = this.isDragging;\n      var isDragging = this.isDragging || this.mouseIsDown && (this.lastMousePos.x !== event.clientX || this.lastMousePos.y !== event.clientY);\n      var isDragStarted = initiaDraggingState === false && isDragging === true;\n      this.lastMousePos = {\n        x: event.clientX,\n        y: event.clientY\n      };\n      if (!isDragging) return;\n      var $root = this.getRoot().$el;\n      var rootRect = $root.getBoundingClientRect();\n      var $dragInfo = this.$refs.dragInfo;\n      var dragInfoTop = event.clientY - rootRect.top + $root.scrollTop - (parseInt($dragInfo.style.marginBottom) | 0);\n      var dragInfoLeft = event.clientX - rootRect.left;\n      $dragInfo.style.top = dragInfoTop + 'px';\n      $dragInfo.style.left = dragInfoLeft + 'px';\n      var cursorPosition = this.getCursorPositionFromCoords(event.clientX, event.clientY);\n      var destNode = cursorPosition.node;\n      var placement = cursorPosition.placement;\n\n      if (isDragStarted && !destNode.isSelected) {\n        if (destNode.path) this.select(destNode.path, false, event);\n      }\n\n      var draggableNodes = this.getDraggable();\n\n      if (!draggableNodes.length) {\n        this.preventDrag = true;\n        return;\n      }\n\n      this.isDragging = isDragging;\n      this.setCursorPosition({\n        node: destNode,\n        placement: placement\n      });\n      var scrollBottomLine = rootRect.bottom - this.scrollAreaHeight;\n      var scrollDownSpeed = (event.clientY - scrollBottomLine) / (rootRect.bottom - scrollBottomLine);\n      var scrollTopLine = rootRect.top + this.scrollAreaHeight;\n      var scrollTopSpeed = (scrollTopLine - event.clientY) / (scrollTopLine - rootRect.top);\n\n      if (scrollDownSpeed > 0) {\n        this.startScroll(scrollDownSpeed);\n      } else if (scrollTopSpeed > 0) {\n        this.startScroll(-scrollTopSpeed);\n      } else {\n        this.stopScroll();\n      }\n    }\n    /**\n     * 鼠标离开\n     */\n\n  }, {\n    key: \"onMouseleaveHandler\",\n    value: function onMouseleaveHandler(event) {\n      if (!this.isRoot || !this.isDragging) return;\n      var $root = this.getRoot().$el;\n      var rootRect = $root.getBoundingClientRect();\n\n      if (event.clientY >= rootRect.bottom) {\n        this.setCursorPosition({\n          node: this.nodes.splice(-1)[0],\n          placement: 'after'\n        });\n      } else if (event.clientY < rootRect.top) {\n        this.setCursorPosition({\n          node: this.getFirstNode(),\n          placement: 'before'\n        });\n      }\n    }\n    /**\n     * 内层 item 鼠标按下\n     */\n\n  }, {\n    key: \"onNodeMousedownHandler\",\n    value: function onNodeMousedownHandler(event, node) {\n      if (event.button !== 0) return;\n\n      if (!this.isRoot) {\n        this.getRoot().onNodeMousedownHandler(event, node);\n        return;\n      } // root\n\n\n      this.mouseIsDown = true;\n    }\n    /**\n     * 鼠标抬起\n     */\n\n  }, {\n    key: \"onNodeMouseupHandler\",\n    value: function onNodeMouseupHandler(event, targetNodet) {\n      if (event.button !== 0) return;\n\n      if (!this.isRoot) {\n        this.getRoot().onNodeMouseupHandler(event, targetNodet);\n        return;\n      }\n\n      this.mouseIsDown = false;\n\n      if (!this.isDragging && targetNodet && !this.preventDrag) {\n        this.select(targetNodet.path, false, event);\n      }\n\n      this.preventDrag = false;\n\n      if (!this.cursorPosition) {\n        this.stopDrag();\n        return;\n      }\n\n      var draggingNodes = this.getDraggable();\n      var _iteratorNormalCompletion = true;\n      var _didIteratorError = false;\n      var _iteratorError = undefined;\n\n      try {\n        for (var _iterator = draggingNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n          var draggingNode = _step.value;\n\n          if (draggingNode.pathStr === this.cursorPosition.node.pathStr) {\n            this.stopDrag();\n            return;\n          }\n\n          if (this.checkNodeIsParent(draggingNode, this.cursorPosition.node)) {\n            this.stopDrag();\n            return;\n          }\n        }\n      } catch (err) {\n        _didIteratorError = true;\n        _iteratorError = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion && _iterator.return != null) {\n            _iterator.return();\n          }\n        } finally {\n          if (_didIteratorError) {\n            throw _iteratorError;\n          }\n        }\n      }\n\n      var newNodes = this.deepCopy(this.currentValue);\n      var nodeModelsSubjectToInsert = [];\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = draggingNodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var _draggingNode = _step2.value;\n          var sourceSiblings = this.getNodeSiblings(newNodes, _draggingNode.path);\n          var draggingNodeModel = sourceSiblings[_draggingNode.ind];\n          nodeModelsSubjectToInsert.push(draggingNodeModel);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {\n            _iterator2.return();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n\n      var cancelled = false;\n      this.emitBeforeDrop(draggingNodes, this.cursorPosition, function () {\n        cancelled = true;\n      });\n\n      if (cancelled) {\n        this.stopDrag();\n        return;\n      }\n\n      var nodeModelsToInsert = [];\n\n      for (var _i = 0, _nodeModelsSubjectToI = nodeModelsSubjectToInsert; _i < _nodeModelsSubjectToI.length; _i++) {\n        var _draggingNodeModel = _nodeModelsSubjectToI[_i];\n        nodeModelsToInsert.push(this.deepCopy(_draggingNodeModel));\n        _draggingNodeModel.markToDelete = true;\n      }\n\n      this.insertModels(this.cursorPosition, nodeModelsToInsert, newNodes);\n      this.traverseModels(function (nodeModel, siblings, ind) {\n        if (!nodeModel.markToDelete) return;\n        siblings.splice(ind, 1);\n      }, newNodes);\n      this.lastSelectedNode = null;\n      this.emitInput(newNodes);\n      this.emitDrop(draggingNodes, this.cursorPosition, event);\n      this.stopDrag();\n    }\n  }, {\n    key: \"onExternalDragoverHandler\",\n    value: function onExternalDragoverHandler(node, event) {\n      event.preventDefault();\n      var root = this.getRoot();\n      var cursorPosition = root.getCursorPositionFromCoords(event.clientX, event.clientY);\n      root.setCursorPosition(cursorPosition);\n      root.$emit('externaldragover', cursorPosition, event);\n    }\n  }, {\n    key: \"onExternalDropHandler\",\n    value: function onExternalDropHandler(node, event) {\n      var root = this.getRoot();\n      var cursorPosition = root.getCursorPositionFromCoords(event.clientX, event.clientY);\n      root.$emit('externaldrop', cursorPosition, event);\n      this.setCursorPosition();\n    }\n  }, {\n    key: \"traverseModels\",\n    value: function traverseModels(cb, nodeModels) {\n      var i = nodeModels.length;\n\n      while (i--) {\n        var nodeModel = nodeModels[i];\n        if (nodeModel.nodes && nodeModel.nodes.length) this.traverseModels(cb, nodeModel.nodes);\n        cb(nodeModel, nodeModels, i);\n      }\n\n      return nodeModels;\n    }\n  }, {\n    key: \"insertModels\",\n    value: function insertModels(cursorPosition, nodeModels, newNodes) {\n      var destNode = cursorPosition.node;\n      var destSiblings = this.getNodeSiblings(newNodes, destNode.path);\n      var destNodeModel = destSiblings[destNode.ind];\n\n      if (cursorPosition.placement === 'inside') {\n        var _destNodeModel$nodes;\n\n        destNodeModel.nodes = destNodeModel.nodes || [];\n\n        (_destNodeModel$nodes = destNodeModel.nodes).unshift.apply(_destNodeModel$nodes, _toConsumableArray(nodeModels));\n      } else {\n        var insertInd = cursorPosition.placement === 'before' ? destNode.ind : destNode.ind + 1;\n        destSiblings.splice.apply(destSiblings, [insertInd, 0].concat(_toConsumableArray(nodeModels)));\n      }\n    }\n  }, {\n    key: \"deepCopy\",\n    value: function deepCopy(value) {\n      return JSON.parse(JSON.stringify(value));\n    }\n  }, {\n    key: \"getNodes\",\n    value: function getNodes(nodeNodels) {\n      var _this2 = this;\n\n      var parentPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var isVisible = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n      return nodeNodels.map(function (nodeModel, inx) {\n        var nodePath = parentPath.concat(inx);\n        return _this2.getNode(nodePath, nodeModel, nodeNodels, isVisible);\n      });\n    }\n  }, {\n    key: \"getNode\",\n    value: function getNode(path, nodeModel, siblings, isVisible) {\n      var ind = path.slice(-1)[0];\n      siblings = siblings || this.getNodeSiblings(this.currentValue, path);\n      nodeModel = nodeModel || siblings && siblings[ind] || null;\n\n      if (!isVisible) {\n        isVisible = this.isVisible(path);\n      }\n\n      var isExpanded = nodeModel.isExpanded === void 0 ? true : !!nodeModel.isExpanded;\n      var isDraggable = nodeModel.isDraggable === void 0 ? true : !!nodeModel.isDraggable;\n      var isSelectable = nodeModel.isSelectable === void 0 ? true : !!nodeModel.isSelectable;\n\n      var _nodeModel = nodeModel,\n          nodes = _nodeModel.nodes,\n          item = _objectWithoutProperties(_nodeModel, [\"nodes\"]);\n\n      var node = _objectSpread({}, item, {\n        nodes: nodes.length ? this.getNodes(nodes, path, isExpanded) : [],\n        isLeaf: !!nodeModel.isLeaf,\n        isExpanded: isExpanded,\n        isVisible: isVisible,\n        isDraggable: isDraggable,\n        isSelectable: isSelectable,\n        path: path,\n        isSelected: !!nodeModel.isSelected,\n        pathStr: JSON.stringify(path),\n        ind: ind,\n        isFirstChild: ind === 0,\n        isLastChild: ind === siblings.length - 1,\n        level: path.length\n      });\n\n      return node;\n    }\n    /**\n     * 获取兄弟节点\n     */\n\n  }, {\n    key: \"getNodeSiblings\",\n    value: function getNodeSiblings(nodes, path) {\n      if (path.length === 1) return nodes;\n      return this.getNodeSiblings(nodes[path[0]].nodes, path.slice(1));\n    }\n  }, {\n    key: \"isVisible\",\n    value: function isVisible(path) {\n      if (path.length < 2) return true;\n      var nodeModels = this.currentValue;\n\n      for (var i = 0; i < path.length - 1; i++) {\n        var ind = path[i];\n        var nodeModel = nodeModels[ind];\n        var isExpanded = nodeModel.isExpanded === void 0 ? true : !!nodeModel.isExpanded;\n        if (!isExpanded) return false;\n        nodeModels = nodeModel.nodes;\n      }\n\n      return true;\n    }\n    /**\n     *  toggle\n     */\n\n  }, {\n    key: \"onToggleHandler\",\n    value: function onToggleHandler(event, node) {\n      this.getRoot().$emit('nodeClick', node);\n      if (!this.allowToggleBranch) return;\n      if (node.path) this.updateNode(node.path, {\n        isExpanded: !node.isExpanded\n      });\n      event.stopPropagation();\n    }\n    /**\n     * 更新 node 数据状态\n     */\n\n  }, {\n    key: \"updateNode\",\n    value: function updateNode(path, patch) {\n      if (!this.isRoot) {\n        this.getParent.updateNode(path, patch);\n        return;\n      }\n\n      var pathStr = JSON.stringify(path);\n      var newNodes = this.deepCopy(this.currentValue);\n      this.traverse(function (node, nodeModel) {\n        if (node.pathStr !== pathStr) return;\n        Object.assign(nodeModel, patch);\n      }, newNodes);\n      this.emitInput(newNodes);\n    }\n  }, {\n    key: \"traverse\",\n    value: function traverse(fn, nodeModels) {\n      var parentPath = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      if (!nodeModels) nodeModels = this.currentValue;\n      var shouldStop = false;\n      var nodes = [];\n\n      for (var inx = 0; inx < nodeModels.length; inx++) {\n        var nodeModel = nodeModels[inx];\n        var itemPath = parentPath.concat(inx);\n        var node = this.getNode(itemPath, nodeModel, nodeModels);\n        shouldStop = fn(node, nodeModel, nodeModels) === false;\n        nodes.push(node);\n        if (shouldStop) break;\n\n        if (nodeModel.nodes) {\n          shouldStop = this.traverse(fn, nodeModel.nodes, itemPath) === false;\n          if (shouldStop) break;\n        }\n      }\n\n      return !shouldStop ? nodes : false;\n    }\n  }, {\n    key: \"getRoot\",\n    value: function getRoot() {\n      if (this.isRoot) return this;\n      return this.getParent.getRoot();\n    }\n    /**\n     * 更新值\n     */\n\n  }, {\n    key: \"emitInput\",\n    value: function emitInput(newValue) {\n      this.currentValue = newValue;\n      this.getRoot().$emit('input', newValue);\n    }\n  }, {\n    key: \"emitSelect\",\n    value: function emitSelect(selectedNodes, event) {\n      this.getRoot().$emit('select', selectedNodes, event);\n    }\n  }, {\n    key: \"emitDrop\",\n    value: function emitDrop(draggingNodes, position, event) {\n      this.getRoot().$emit('drop', draggingNodes, position, event);\n    }\n  }, {\n    key: \"getCursorPositionFromCoords\",\n    value: function getCursorPositionFromCoords(x, y) {\n      var $target = document.elementFromPoint(x, y); // 查找当前拖拽的node\n\n      var $nodeItem = $target.getAttribute('path') ? $target : this.getClosetElementWithPath($target);\n      var destNode;\n      var placement;\n\n      if ($nodeItem) {\n        destNode = this.getNode(JSON.parse($nodeItem.getAttribute('path')));\n        var nodeHeight = $nodeItem.offsetHeight;\n        var edgeSize = this.edgeSize;\n        var offsetY = y - $nodeItem.getBoundingClientRect().top;\n\n        if (destNode.isLeaf) {\n          placement = offsetY >= nodeHeight / 2 ? 'after' : 'before';\n        } else {\n          if (offsetY <= edgeSize) {\n            placement = 'before';\n          } else if (offsetY >= nodeHeight - edgeSize) {\n            placement = 'after';\n          } else {\n            placement = 'inside';\n          }\n        }\n      } else {\n        var $root = this.getRoot().$el;\n        var rootRect = $root.getBoundingClientRect();\n\n        if (y > rootRect.top + rootRect.height / 2) {\n          placement = 'after';\n          destNode = this.getLastNode();\n        } else {\n          placement = 'before';\n          destNode = this.getFirstNode();\n        }\n      }\n\n      return {\n        node: destNode,\n        placement: placement\n      };\n    }\n  }, {\n    key: \"onDocumentMouseupHandler\",\n    value: function onDocumentMouseupHandler(event) {\n      if (this.isDragging) this.onNodeMouseupHandler(event);\n    }\n  }, {\n    key: \"getClosetElementWithPath\",\n    value: function getClosetElementWithPath($el) {\n      if (!$el) return null;\n      if ($el.getAttribute('path')) return $el;\n      return this.getClosetElementWithPath($el.parentElement);\n    }\n  }, {\n    key: \"getLastNode\",\n    value: function getLastNode() {\n      var lastNode;\n      this.traverse(function (node) {\n        lastNode = node;\n      });\n      return lastNode;\n    }\n  }, {\n    key: \"getFirstNode\",\n    value: function getFirstNode() {\n      return this.getNode([0]);\n    }\n  }, {\n    key: \"select\",\n    value: function select(path) {\n      var addToSelection = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var event = arguments.length > 2 ? arguments[2] : undefined;\n      var selectedNode = this.getNode(path);\n      if (!selectedNode) return null;\n      var newNodes = this.deepCopy(this.currentValue);\n      var selectedNodes = [];\n      this.traverse(function (node, nodeModel) {\n        if (node.pathStr === selectedNode.pathStr) {\n          nodeModel.isSelected = node.isSelectable;\n        } else if (!addToSelection) {\n          if (nodeModel.isSelected) nodeModel.isSelected = false;\n        }\n\n        if (nodeModel.isSelected) selectedNodes.push(node);\n      }, newNodes);\n      this.lastSelectedNode = selectedNode;\n      this.emitInput(newNodes);\n      this.emitSelect(selectedNodes, event);\n      return selectedNode;\n    }\n  }, {\n    key: \"getDraggable\",\n    value: function getDraggable() {\n      var selectedNodes = [];\n      this.traverse(function (node) {\n        if (node.isSelected && node.isDraggable) selectedNodes.push(node);\n      });\n      return selectedNodes;\n    }\n  }, {\n    key: \"setCursorPosition\",\n    value: function setCursorPosition(pos) {\n      if (this.isRoot) {\n        this.rootCursorPosition = pos;\n        return;\n      }\n\n      this.getParent.setCursorPosition(pos);\n    }\n  }, {\n    key: \"checkNodeIsParent\",\n    value: function checkNodeIsParent(sourceNode, destNode) {\n      var destPath = destNode.path;\n      var sourcePath = sourceNode.path;\n      return JSON.stringify(destPath.slice(0, sourcePath.length)) === sourceNode.pathStr;\n    }\n  }, {\n    key: \"startScroll\",\n    value: function startScroll(speed) {\n      var _this3 = this;\n\n      var $root = this.getRoot().$el;\n\n      if (this.scrollSpeed === speed) {\n        return;\n      } else if (this.scrollIntervalId) {\n        this.stopScroll();\n      }\n\n      this.scrollSpeed = speed;\n      this.scrollIntervalId = setInterval(function () {\n        $root.scrollTop += _this3.maxScrollSpeed * speed;\n      }, 20);\n    }\n  }, {\n    key: \"emitBeforeDrop\",\n    value: function emitBeforeDrop(draggingNodes, position, cancel) {\n      this.getRoot().$emit('beforedrop', draggingNodes, position, cancel);\n    }\n  }, {\n    key: \"emitNodeContextmenu\",\n    value: function emitNodeContextmenu(node, event) {\n      this.getRoot().$emit('nodecontextmenu', node, event);\n    }\n  }, {\n    key: \"stopScroll\",\n    value: function stopScroll() {\n      clearInterval(this.scrollIntervalId);\n      this.scrollIntervalId = 0;\n      this.scrollSpeed = 0;\n    }\n  }, {\n    key: \"stopDrag\",\n    value: function stopDrag() {\n      this.isDragging = false;\n      this.mouseIsDown = false;\n      this.setCursorPosition();\n      this.stopScroll();\n    }\n  }, {\n    key: \"isRoot\",\n    get: function get() {\n      return !this.level;\n    }\n  }, {\n    key: \"cursorPosition\",\n    get: function get() {\n      if (this.isRoot) return this.rootCursorPosition;\n      return this.getParent.cursorPosition;\n    }\n  }, {\n    key: \"nodes\",\n    get: function get() {\n      if (this.isRoot) {\n        var nodeModels = this.deepCopy(this.currentValue);\n        return this.getNodes(nodeModels);\n      } // console.log('this.parentInd', this.parentInd)\n\n\n      return this.getParent.nodes[this.parentInd].nodes;\n    }\n  }, {\n    key: \"getParent\",\n    get: function get() {\n      return this.$parent;\n    }\n    /**\n     * 生成间距\n     */\n\n  }, {\n    key: \"gaps\",\n    get: function get() {\n      var gaps = [];\n      var i = this.level - 1;\n      if (!this.showBranches) i++;\n\n      while (i-- > 0) {\n        gaps.push(i);\n      }\n\n      return gaps;\n    }\n  }]);\n\n  return default_1;\n}(Vue);\n\ntslib_1.__decorate([Prop({\n  default: 0\n})], default_1.prototype, \"level\", void 0);\n\ntslib_1.__decorate([Prop({\n  default: []\n})], default_1.prototype, \"value\", void 0);\n\ntslib_1.__decorate([Prop()], default_1.prototype, \"parentInd\", void 0);\n\ntslib_1.__decorate([Prop({\n  default: false\n})], default_1.prototype, \"showBranches\", void 0);\n\ntslib_1.__decorate([Prop({\n  default: 3\n})], default_1.prototype, \"edgeSize\", void 0);\n\ntslib_1.__decorate([Prop({\n  default: true,\n  type: Boolean\n})], default_1.prototype, \"allowToggleBranch\", void 0);\n\ntslib_1.__decorate([Watch('value')], default_1.prototype, \"onValueChange\", null);\n\ndefault_1 = tslib_1.__decorate([Component({\n  name: 'DragTree'\n})], default_1);\nexport default default_1;",null]}