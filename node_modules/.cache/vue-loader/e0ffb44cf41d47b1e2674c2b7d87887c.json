{"remainingRequest":"/Users/lanjianhua/Desktop/lanjianhua/blog/blog-web/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/lanjianhua/Desktop/lanjianhua/blog/blog-web/src/components/DragTree/index.vue?vue&type=script&lang=ts&","dependencies":[{"path":"/Users/lanjianhua/Desktop/lanjianhua/blog/blog-web/src/components/DragTree/index.vue","mtime":1588936943309},{"path":"/Users/lanjianhua/Desktop/lanjianhua/blog/blog-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/lanjianhua/Desktop/lanjianhua/blog/blog-web/node_modules/babel-loader/lib/index.js","mtime":499162500000},{"path":"/Users/lanjianhua/Desktop/lanjianhua/blog/blog-web/node_modules/ts-loader/index.js","mtime":499162500000},{"path":"/Users/lanjianhua/Desktop/lanjianhua/blog/blog-web/node_modules/cache-loader/dist/cjs.js","mtime":499162500000},{"path":"/Users/lanjianhua/Desktop/lanjianhua/blog/blog-web/node_modules/vue-loader/lib/index.js","mtime":499162500000}],"contextDependencies":[],"result":["\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nimport { Component, Vue, Watch, Prop } from 'vue-property-decorator'\nimport { ITreeNode, DragTree, ITraverse, placement, ICancelFn, ITraverseModels } from './type'\nimport { TreeNode } from 'element-ui/types/tree'\n@Component({\n  name: 'DragTree'\n})\n\nexport default class extends Vue {\n  @Prop({ default: 0 }) private level!: number\n  @Prop({ default: [] }) private value!: ITreeNode[]\n  @Prop() private parentInd!: number\n  @Prop({ default: false }) private showBranches!:boolean\n  @Prop({ default: 3 }) private edgeSize!: number\n  @Prop({ default: true, type: Boolean }) private allowToggleBranch!: boolean\n  private rootCursorPosition: { node: ITreeNode, placement: placement} | undefined = {\n    node: { nodes: [], level: 0, pathStr: '', ind: 1, path: [] },\n    placement: 'before'\n  }\n  private currentValue: ITreeNode[] = this.value\n  private preventDrag: boolean = false\n  private isDragging: boolean = false\n  private mouseIsDown: boolean = false\n  private lastSelectedNode: ITreeNode | {} = {}\n  private scrollAreaHeight: number = 70\n  private scrollSpeed: number = 0\n  private scrollIntervalId: any = 0\n  private maxScrollSpeed: number = 20\n  private lastMousePos: { x: number, y: number} = {\n    x: 0,\n    y: 0\n  }\n  get isRoot() {\n    return !this.level\n  }\n  get cursorPosition() {\n    if (this.isRoot) return this.rootCursorPosition\n    return this.getParent.cursorPosition\n  }\n  get nodes() {\n    if (this.isRoot) {\n      const nodeModels = this.deepCopy(this.currentValue)\n      return this.getNodes(nodeModels)\n    }\n    // console.log('this.parentInd', this.parentInd)\n    return this.getParent.nodes[this.parentInd].nodes\n  }\n  get getParent(): DragTree {\n    return this.$parent as DragTree\n  }\n  /**\n   * 生成间距\n   */\n  get gaps() {\n    const gaps = []\n    let i = this.level - 1\n    if (!this.showBranches) i++\n    while (i-- > 0) gaps.push(i)\n    return gaps\n  }\n  @Watch('value')\n  private onValueChange(value: ITreeNode[]) {\n    this.currentValue = value\n  }\n  mounted() {\n    if (this.isRoot) {\n      document.addEventListener('mouseup', this.onDocumentMouseupHandler)\n    }\n  }\n  beforeDestroy() {\n    document.removeEventListener('mouseup', this.onDocumentMouseupHandler)\n  }\n  /**\n   * tree 外层 鼠标移动\n   */\n  private onMousemoveHandler(event: MouseEvent) {\n    if (!this.isRoot) {\n      (this.getRoot() as DragTree).onMousemoveHandler(event)\n      return\n    }\n    if (this.preventDrag) return\n    const initiaDraggingState = this.isDragging\n    const isDragging =\n      this.isDragging || (\n        this.mouseIsDown &&\n        (this.lastMousePos.x !== event.clientX || this.lastMousePos.y !== event.clientY)\n      )\n    const isDragStarted = initiaDraggingState === false && isDragging === true\n    this.lastMousePos = {\n      x: event.clientX,\n      y: event.clientY\n    }\n    if (!isDragging) return\n    const $root = this.getRoot().$el\n    const rootRect = $root.getBoundingClientRect()\n    const $dragInfo = this.$refs.dragInfo as HTMLDivElement\n    const dragInfoTop = event.clientY - rootRect.top + $root.scrollTop - (parseInt($dragInfo.style.marginBottom as string) | 0)\n    const dragInfoLeft = (event.clientX - rootRect.left)\n    $dragInfo.style.top = dragInfoTop + 'px'\n    $dragInfo.style.left = dragInfoLeft + 'px'\n\n    const cursorPosition = this.getCursorPositionFromCoords(event.clientX, event.clientY)\n    const destNode = cursorPosition.node as ITreeNode\n    const placement = cursorPosition.placement\n\n    if (isDragStarted && !destNode.isSelected) {\n      if (destNode.path) this.select(destNode.path, false, event)\n    }\n    const draggableNodes = this.getDraggable()\n    if (!draggableNodes.length) {\n      this.preventDrag = true\n      return\n    }\n    this.isDragging = isDragging\n    this.setCursorPosition({ node: destNode, placement })\n    const scrollBottomLine = rootRect.bottom - this.scrollAreaHeight\n    const scrollDownSpeed = (event.clientY - scrollBottomLine) / (rootRect.bottom - scrollBottomLine)\n    const scrollTopLine = rootRect.top + this.scrollAreaHeight\n    const scrollTopSpeed = (scrollTopLine - event.clientY) / (scrollTopLine - rootRect.top)\n    if (scrollDownSpeed > 0) {\n      this.startScroll(scrollDownSpeed)\n    } else if (scrollTopSpeed > 0) {\n      this.startScroll(-scrollTopSpeed)\n    } else {\n      this.stopScroll()\n    }\n  }\n  /**\n   * 鼠标离开\n   */\n  private onMouseleaveHandler(event: MouseEvent) {\n    if (!this.isRoot || !this.isDragging) return\n    const $root = this.getRoot().$el\n    const rootRect = $root.getBoundingClientRect()\n    if (event.clientY >= rootRect.bottom) {\n      this.setCursorPosition({ node: this.nodes.splice(-1)[0], placement: 'after' })\n    } else if (event.clientY < rootRect.top) {\n      this.setCursorPosition({ node: this.getFirstNode(), placement: 'before' })\n    }\n  }\n  /**\n   * 内层 item 鼠标按下\n   */\n  private onNodeMousedownHandler(event: MouseEvent, node: ITreeNode) {\n    if (event.button !== 0) return\n    if (!this.isRoot) {\n      (this.getRoot() as DragTree).onNodeMousedownHandler(event, node)\n      return\n    }\n    // root\n    this.mouseIsDown = true\n  }\n  /**\n   * 鼠标抬起\n   */\n  private onNodeMouseupHandler(event: MouseEvent, targetNodet?: ITreeNode) {\n    if (event.button !== 0) return\n    if (!this.isRoot) {\n      (this.getRoot() as DragTree).onNodeMouseupHandler(event, targetNodet as any)\n      return\n    }\n    this.mouseIsDown = false\n    if (!this.isDragging && targetNodet && !this.preventDrag) {\n      this.select(targetNodet.path as number[], false, event)\n    }\n    this.preventDrag = false\n    if (!this.cursorPosition) {\n      this.stopDrag()\n      return\n    }\n    const draggingNodes = this.getDraggable()\n    for (let draggingNode of draggingNodes) {\n      if (draggingNode.pathStr === this.cursorPosition.node.pathStr) {\n        this.stopDrag()\n        return\n      }\n      if (this.checkNodeIsParent(draggingNode, this.cursorPosition.node)) {\n        this.stopDrag()\n        return\n      }\n    }\n    const newNodes = this.deepCopy(this.currentValue)\n    const nodeModelsSubjectToInsert: ITreeNode[] = []\n    for (let draggingNode of draggingNodes) {\n      const sourceSiblings = this.getNodeSiblings(newNodes, draggingNode.path)\n      const draggingNodeModel = sourceSiblings[draggingNode.ind]\n      nodeModelsSubjectToInsert.push(draggingNodeModel)\n    }\n    let cancelled = false\n    this.emitBeforeDrop(draggingNodes, this.cursorPosition, () => { cancelled = true })\n    if (cancelled) {\n      this.stopDrag()\n      return\n    }\n    const nodeModelsToInsert: ITreeNode[] = []\n    for (let draggingNodeModel of nodeModelsSubjectToInsert) {\n      nodeModelsToInsert.push(this.deepCopy(draggingNodeModel))\n      draggingNodeModel.markToDelete = true\n    }\n    this.insertModels(this.cursorPosition, nodeModelsToInsert, newNodes)\n    this.traverseModels((nodeModel, siblings, ind) => {\n      if (!nodeModel.markToDelete) return\n      siblings.splice(ind, 1)\n    }, newNodes);\n    (this.lastSelectedNode as any) = null\n    this.emitInput(newNodes)\n    this.emitDrop(draggingNodes, this.cursorPosition, event)\n    this.stopDrag()\n  }\n  private onExternalDragoverHandler(node: ITreeNode, event: MouseEvent) {\n    event.preventDefault()\n    const root = this.getRoot() as DragTree\n    const cursorPosition = root.getCursorPositionFromCoords(event.clientX, event.clientY)\n    root.setCursorPosition(cursorPosition)\n    root.$emit('externaldragover', cursorPosition, event)\n  }\n  private onExternalDropHandler(node: ITreeNode, event: MouseEvent) {\n    const root = this.getRoot() as DragTree\n    const cursorPosition = root.getCursorPositionFromCoords(event.clientX, event.clientY)\n    root.$emit('externaldrop', cursorPosition, event)\n    this.setCursorPosition()\n  }\n  private traverseModels(cb: ITraverseModels, nodeModels: ITreeNode[]) {\n    let i = nodeModels.length\n    while (i--) {\n      const nodeModel = nodeModels[i]\n      if (nodeModel.nodes && nodeModel.nodes.length) this.traverseModels(cb, nodeModel.nodes)\n      cb(nodeModel, nodeModels, i)\n    }\n    return nodeModels\n  }\n  private insertModels(cursorPosition: { node: ITreeNode, placement: placement }, nodeModels: ITreeNode[], newNodes: ITreeNode[]) {\n    const destNode = cursorPosition.node\n    const destSiblings = this.getNodeSiblings(newNodes, destNode.path)\n    const destNodeModel = destSiblings[destNode.ind]\n    if (cursorPosition.placement === 'inside') {\n      destNodeModel.nodes = destNodeModel.nodes || []\n      destNodeModel.nodes.unshift(...nodeModels)\n    } else {\n      const insertInd = cursorPosition.placement === 'before' ? destNode.ind : destNode.ind + 1\n      destSiblings.splice(insertInd, 0, ...nodeModels)\n    }\n  }\n  private deepCopy(value: any) {\n    return JSON.parse(JSON.stringify(value))\n  }\n  private getNodes(nodeNodels: ITreeNode[], parentPath:number[] = [], isVisible = true) {\n    return nodeNodels.map((nodeModel, inx) => {\n      const nodePath = parentPath.concat(inx)\n      return this.getNode(nodePath, nodeModel, nodeNodels, isVisible)\n    })\n  }\n  private getNode(path: number[], nodeModel?: ITreeNode, siblings?: ITreeNode[], isVisible?: boolean): ITreeNode {\n    const ind = path.slice(-1)[0]\n    siblings = siblings || this.getNodeSiblings(this.currentValue, path)\n    nodeModel = nodeModel || (siblings && siblings[ind]) || null\n    if (!isVisible) {\n      isVisible = this.isVisible(path)\n    }\n    const isExpanded = nodeModel.isExpanded === void 0 ? true : !!nodeModel.isExpanded\n    const isDraggable = nodeModel.isDraggable === void 0 ? true : !!nodeModel.isDraggable\n    const isSelectable = nodeModel.isSelectable === void 0 ? true : !!nodeModel.isSelectable\n    let { nodes, ...item } = nodeModel\n    const node:ITreeNode = {\n      ...item,\n      nodes: nodes.length ? this.getNodes(nodes, path, isExpanded) : [],\n      isLeaf: !!nodeModel.isLeaf,\n      isExpanded,\n      isVisible,\n      isDraggable,\n      isSelectable,\n      path: path,\n      isSelected: !!nodeModel.isSelected,\n      pathStr: JSON.stringify(path),\n      ind,\n      isFirstChild: ind === 0,\n      isLastChild: ind === siblings.length - 1,\n      level: path.length\n    }\n    return node\n  }\n  /**\n   * 获取兄弟节点\n   */\n  private getNodeSiblings(nodes: ITreeNode[], path: number[]): ITreeNode[] {\n    if (path.length === 1) return nodes\n    return this.getNodeSiblings(nodes[path[0]].nodes, path.slice(1))\n  }\n  private isVisible(path: number[]) {\n    if (path.length < 2) return true\n    let nodeModels = this.currentValue\n    for (let i = 0; i < path.length - 1; i++) {\n      let ind = path[i]\n      let nodeModel = nodeModels[ind]\n      let isExpanded = nodeModel.isExpanded === void 0 ? true : !!nodeModel.isExpanded\n      if (!isExpanded) return false\n      nodeModels = nodeModel.nodes\n    }\n    return true\n  }\n  /**\n   *  toggle\n   */\n  private onToggleHandler(event: Event, node: ITreeNode) {\n    this.getRoot().$emit('nodeClick', node)\n    if (!this.allowToggleBranch) return\n    if (node.path) this.updateNode(node.path, { isExpanded: !node.isExpanded })\n    event.stopPropagation()\n  }\n  /**\n   * 更新 node 数据状态\n   */\n  private updateNode(path: number[], patch: {isExpanded: boolean}) {\n    if (!this.isRoot) {\n      this.getParent.updateNode(path, patch)\n      return\n    }\n    const pathStr = JSON.stringify(path)\n    const newNodes = this.deepCopy(this.currentValue) as ITreeNode[]\n    this.traverse((node, nodeModel) => {\n      if (node.pathStr !== pathStr) return\n      Object.assign(nodeModel, patch)\n    }, newNodes)\n    this.emitInput(newNodes)\n  }\n  private traverse(fn:ITraverse, nodeModels?: ITreeNode[], parentPath: number[] = []): ITreeNode[] | boolean {\n    if (!nodeModels) nodeModels = this.currentValue\n    let shouldStop = false\n    const nodes:ITreeNode[] = []\n    for (let inx = 0; inx < nodeModels.length; inx++) {\n      const nodeModel = nodeModels[inx]\n      const itemPath = parentPath.concat(inx)\n      const node = this.getNode(itemPath, nodeModel, nodeModels)\n      shouldStop = fn(node, nodeModel, nodeModels) === false\n      nodes.push(node)\n      if (shouldStop) break\n      if (nodeModel.nodes) {\n        shouldStop = this.traverse(fn, nodeModel.nodes, itemPath) === false\n        if (shouldStop) break\n      }\n    }\n    return !shouldStop ? nodes : false\n  }\n  private getRoot() {\n    if (this.isRoot) return this\n    return this.getParent.getRoot()\n  }\n  /**\n   * 更新值\n   */\n  private emitInput(newValue: ITreeNode[]) {\n    this.currentValue = newValue\n    this.getRoot().$emit('input', newValue)\n  }\n  private emitSelect(selectedNodes: ITreeNode[], event?: MouseEvent) {\n    this.getRoot().$emit('select', selectedNodes, event)\n  }\n  private emitDrop(draggingNodes: ITreeNode[], position: { node: ITreeNode, placement: placement }, event: MouseEvent) {\n    this.getRoot().$emit('drop', draggingNodes, position, event)\n  }\n\n  private getCursorPositionFromCoords(x: number, y: number) {\n    const $target = document.elementFromPoint(x, y) as HTMLElement\n    // 查找当前拖拽的node\n    const $nodeItem = $target.getAttribute('path') ? $target : this.getClosetElementWithPath($target)\n    let destNode\n    let placement: placement\n    if ($nodeItem) {\n      destNode = this.getNode(JSON.parse($nodeItem.getAttribute('path') as string))\n      const nodeHeight = $nodeItem.offsetHeight\n      const edgeSize = this.edgeSize\n      const offsetY = y - $nodeItem.getBoundingClientRect().top\n      if (destNode.isLeaf) {\n        placement = offsetY >= nodeHeight / 2 ? 'after' : 'before'\n      } else {\n        if (offsetY <= edgeSize) {\n          placement = 'before'\n        } else if (offsetY >= nodeHeight - edgeSize) {\n          placement = 'after'\n        } else {\n          placement = 'inside'\n        }\n      }\n    } else {\n      const $root = this.getRoot().$el\n      const rootRect = $root.getBoundingClientRect()\n      if (y > rootRect.top + (rootRect.height / 2)) {\n        placement = 'after'\n        destNode = this.getLastNode()\n      } else {\n        placement = 'before'\n        destNode = this.getFirstNode()\n      }\n    }\n    return { node: destNode, placement }\n  }\n  private onDocumentMouseupHandler(event: MouseEvent) {\n    if (this.isDragging) this.onNodeMouseupHandler(event)\n  }\n  private getClosetElementWithPath($el: HTMLElement | null): HTMLElement | null {\n    if (!$el) return null\n    if ($el.getAttribute('path')) return $el\n    return this.getClosetElementWithPath($el.parentElement)\n  }\n  private getLastNode() {\n    let lastNode\n    this.traverse(node => {\n      lastNode = node\n    })\n    return lastNode\n  }\n  private getFirstNode() {\n    return this.getNode([0])\n  }\n  private select(path: number[], addToSelection = false, event?: MouseEvent) {\n    const selectedNode = this.getNode(path)\n    if (!selectedNode) return null\n    const newNodes = this.deepCopy(this.currentValue)\n    const selectedNodes: ITreeNode[] = []\n    this.traverse((node, nodeModel) => {\n      if (node.pathStr === selectedNode.pathStr) {\n        nodeModel.isSelected = node.isSelectable\n      } else if (!addToSelection) {\n        if (nodeModel.isSelected) nodeModel.isSelected = false\n      }\n      if (nodeModel.isSelected) selectedNodes.push(node)\n    }, newNodes)\n    this.lastSelectedNode = selectedNode\n    this.emitInput(newNodes)\n    this.emitSelect(selectedNodes, event)\n    return selectedNode\n  }\n  private getDraggable() {\n    const selectedNodes: ITreeNode[] = []\n    this.traverse(node => {\n      if (node.isSelected && node.isDraggable) selectedNodes.push(node)\n    })\n    return selectedNodes\n  }\n  private setCursorPosition(pos?: { node: ITreeNode, placement: placement}) {\n    if (this.isRoot) {\n      this.rootCursorPosition = pos\n      return\n    }\n    this.getParent.setCursorPosition(pos)\n  }\n  private checkNodeIsParent(sourceNode: ITreeNode, destNode: ITreeNode) {\n    const destPath = destNode.path as number[]\n    const sourcePath = sourceNode.path as number []\n    return JSON.stringify(destPath.slice(0, sourcePath.length)) === sourceNode.pathStr\n  }\n  private startScroll(speed: number) {\n    const $root = this.getRoot().$el\n    if (this.scrollSpeed === speed) {\n      return\n    } else if (this.scrollIntervalId) {\n      this.stopScroll()\n    }\n    this.scrollSpeed = speed\n    this.scrollIntervalId = setInterval(() => {\n      $root.scrollTop += this.maxScrollSpeed * speed\n    }, 20)\n  }\n  private emitBeforeDrop(draggingNodes: ITreeNode[], position: { node: ITreeNode, placement: placement }, cancel: ICancelFn) {\n    this.getRoot().$emit('beforedrop', draggingNodes, position, cancel)\n  }\n  private emitNodeContextmenu(node: ITreeNode, event: MouseEvent) {\n    this.getRoot().$emit('nodecontextmenu', node, event)\n  }\n  private stopScroll() {\n    clearInterval(this.scrollIntervalId)\n    this.scrollIntervalId = 0\n    this.scrollSpeed = 0\n  }\n  private stopDrag() {\n    this.isDragging = false\n    this.mouseIsDown = false\n    this.setCursorPosition()\n    this.stopScroll()\n  }\n}\n",null]}